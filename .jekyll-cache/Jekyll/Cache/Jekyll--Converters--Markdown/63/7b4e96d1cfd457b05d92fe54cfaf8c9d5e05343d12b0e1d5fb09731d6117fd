I"Ì<!-- MarkdownTOC -->

<ul>
  <li><a href="#-tich-chap-mot-chieu">1. Tích chập một chiều</a>
    <ul>
      <li><a href="#-dinh-nghia">1.1. Định nghĩa</a></li>
      <li><a href="#-them-le">1.2. Thêm lề</a></li>
      <li><a href="#-buoc-truot">1.3. Bước trượt</a></li>
    </ul>
  </li>
  <li><a href="#-tich-chap-hai-chieu">2. Tích chập hai chiều</a>
    <ul>
      <li><a href="#-tin-hieu-don-kenh">2.1. Tín hiệu đơn kênh</a></li>
    </ul>
  </li>
  <li><a href="#-tich-chap-hai-chieu-tong-quat">3. Tích chập hai chiều tổng quát</a></li>
  <li><a href="#-ket-luan">4. Kết luận</a></li>
  <li><a href="#-tai-lieu-tham-khao">5. Tài liệu tham khảo</a></li>
</ul>

<!-- /MarkdownTOC -->

<p>Tích chập đóng một vai trò quan trọng và xuất hiện từ sớm 
trong lịch sử xử lý tín hiệu số. Việc tìm ra các bộ lọc phù hợp cho mỗi loại tín hiệu 
và mỗi bài toán đã được nghiên cứu và giảng dạy rất nhiều trong các giáo trình kỹ thuật.</p>

<p>Cuối những năm 1980s, Yann Lecunn đề xuất một mô hình tích chập hai chiều cho dữ
liệu ảnh và thu lại thành công lớn trong bài toán phân loại chữ số viết tay.
Bằng việc sử dụng rất nhiều dữ liệu và thay các <em>tầng nối kín</em> (fully connected
layer) trong mạng perceptron đa tầng bởi tích chập hai chiều, các bộ lọc phù hợp
với bài toán và dữ liệu có thể được <em>học</em> để mang lại kết quả phân lớp tốt nhất.</p>

<p>Trong bài viết này, tôi sẽ trình bày cơ sở toán học của tích chập một chiều và
tích chập hai chiều. Kiến trục mạng neuron tích chập sẽ được trình bày cụ thể trong bài tiếp theo.</p>

<p><a name="-tich-chap-mot-chieu"></a></p>

<h2 id="1-tích-chập-một-chiều">1. Tích chập một chiều</h2>

<p><a name="-dinh-nghia"></a></p>

<h3 id="11-định-nghĩa">1.1. Định nghĩa</h3>

<p>Xét tín hiệu một chiều <code class="language-plaintext highlighter-rouge">x_clean</code> có dạng hình sin như trong Hình 1a):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import numpy as np
N = 200
x_clean = np.sin(np.arange(N)/20.)
</code></pre></div></div>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/python/conv1d.png" width="800" />
</div>
<div class="thecap">Hình 1: (a) Tín hiệu ban đầu. (b) Tín hiệu có nhiễu Gauss. (c) Tín hiệu sau khi khử nhiễu bằng tích chập với bộ lọc trung bình.</div>
</div>
<hr />

<p>Tín hiệu này bị tác động bởi nhiễu Gauss:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_noisy</span> <span class="o">=</span> <span class="n">x_clean</span> <span class="o">+</span> <span class="p">.</span><span class="mi">05</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
</code></pre></div></div>
<p>Lúc này, tín hiệu không mượt nữa mà có dạng răng cưa như Hình 1b).</p>

<p>Chỉ với một bộ lọc trung bình đơn giản, ta có thể thu được tín hiệu ít nhiễu hơn
như trong Hình 1c):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">x_filtered</span> <span class="o">=</span> <span class="n">conv1d</span><span class="p">(</span><span class="n">x_noisy</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> 
</code></pre></div></div>
<p>Ở đây, hàm <code class="language-plaintext highlighter-rouge">conv1d</code> thực hiện việc lấy tích chập giữa tín hiệu <code class="language-plaintext highlighter-rouge">x_noisy</code> và bộ
lọc trung bình <code class="language-plaintext highlighter-rouge">w</code>. Hàm số này sẽ được trình bày ở phần dưới. Trước hết, chúng
ta nhắc lại công thức tính tích chập một chiều trong xử lý tín hiệu số.</p>

<p>Xét tín hiệu một chiều \(a(n)\) và <em>bộ lọc</em> (filter) \(w(n)\). Tích chập của tín hiệu và bộ lọc
là một tín hiệu một chiều mới \(b(n)\) được xác định theo công thức:</p>

\[b(n) = a(n)*w(n) = \sum_{k=-\infty}^{\infty}a(k)w(n-k)\quad \quad (1)\]

<p>Trong mạng neuron tích chập, tích chập được định nghĩa khác đi một chút. Cho tín
hiệu đầu vào và bộ lọc lần lượt là các vector \(\mathbf{a}\in \mathbb{R}^N\) và
\(\mathbf{w} \in \mathbb{R}^f\) (\(f\) có thể là một số tự nhiên bất kỳ nhưng thường
là số lẻ). Khi đó đầu ra là một vector \(\mathbf{y}\) với từng phần tử được tính bởi:</p>

\[y_n = \sum_{i=0}^{f-1}a_{n+i}w_i\quad \quad (2)\]

<p>với \(n\) thỏa mãn \(0 \leq n+i &lt; N, ~\forall i = 0, 1, \dots, f-1\). Điều này tương
đương với \(0 \leq n &lt; N - f + 1\). Vậy \(\mathbf{y} \in \mathbb{R}^{N-f + 1}\).</p>

<p>Từ đây, khi đề cập tới khái niệm <em>tích chập</em>, chúng ta sẽ ngầm hiểu công thức
(2) đang được sử dụng.</p>

<p>Cách tính tín hiệu đầu ra \(\mathbf{y}\) được minh họa trong Hình 2.</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/conv1d_viz.png" width="800" />
</div>
<div class="thecap">Hình 2: Cách tính tích chập một chiều</div>
</div>
<hr />

<p>Quá trình tính đầu ra \(\mathbf{y}\) có thể được thực hiện như sau:</p>
<ol>
  <li>
    <p>Đặt bộ lọc \(\mathbf{w}\) vào vị trí tương ứng với \(f\) phần tử đầu tiên của
\(\mathbf{a}\).</p>
  </li>
  <li>
    <p>Nhân từng phần tử tương ứng của \(\mathbf{w}\) và \(\mathbf{a}\) rồi cộng các kết
quả lại để được phẩn tử tương ứng của \(\mathbf{y}\).</p>
  </li>
  <li>
    <p><em>Trượt</em> bộ lọc \(\mathbf{w}\) một bước sang bên phải. Nếu phần tử cuối cùng của
bộ lọc không vượt ra ngoài phần tử cuối cùng của tín hiệu, quay lại Bước 2.
Ngược lại, dừng các bước tính toán.</p>
  </li>
</ol>

<p>Trong ví dụ này:</p>

\[y_0 = a_0w_0 + a_1w_1 + a_2w_2 = 1 - (-1) = 2,\\\ y_1 = a_1w_0 + a_2w_1 + a_3w_2
= 3 - 2 = 1\]

<p><a name="-them-le"></a></p>

<h3 id="12-thêm-lề">1.2. Thêm lề</h3>

<p>Nhận thấy rằng kích thước của đầu ra \(\mathbf{y}\) nhỏ hơn kích thước của đầu vào
\(\mathbf{x}\) vì ta đang giả sử cả bộ lọc phải nằm trọn vẹn trong tín hiệu đầu
vào.</p>

<p>Trong trường hợp muốn tín hiệu đầu ra có kích thước bằng tín hiệu đầu vào, ta
có thể giả sử giả sử tín hiệu đầu vào có thêm các giá trị bằng không ở hai phía.
Kỹ thuật này được gọi là <em>thêm lề</em> (padding). Để có kích thước bằng nhau, tín
hiệu đầu vào cần được thêm \(f-1\) giá trị bằng không. Khi \(f\) là một số lẻ, mỗi
phía của tín hiệu vào thường được thêm \(P = (f-1)/2\) giá trị bằng không.</p>

<p>Giá trị \(P\) có thể là một số tự nhiên bất kỳ tùy thuộc vào từng trường hợp, \(P\)
không nhất thiết phải đảm bảo kích thước đầu ra và đầu vào của tín hiệu là như
nhau. Khi không sử dụng thêm lề, \(P = 0\).</p>

<p>Việc thêm lề được minh họa trong Hình 3. Khi \(f = 3\), ta thêm \(P=1\) ô bằng không vào mỗi phía của \(\mathbf{a}\). Khi đó \(\mathbf{y}\) và \(\mathbf{a}\) có kích thước như nhau.</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/conv1d_padding.png" width="800" />
</div>
<div class="thecap">Hình 3: Tích chập với thêm lề</div>
</div>
<hr />

<p><a name="-buoc-truot"></a></p>

<h3 id="13-bước-trượt">1.3. Bước trượt</h3>
<p>Trong Hình 2, bộ lọc \(\mathbf{w}\) được dịch sang phải một ô sau mỗi phép tính.
Trong một số trường hợp, ta có thể dịch bộ lọc đi nhiều ô sau mỗi phép tính. Số
lượng ô được dịch này được gọi là <em>bước trượt</em> (stride), ký hiệu là \(S\). Lúc
này, công thức tổng quát của (2) trở thành:</p>

\[y_n = \sum_{i=0}^{f-1}a_{nS + i}w_i \quad \quad (3)\]

<p>Trong trường hợp có sử dụng thêm lề với độ rộng lề mỗi phía là \(P\), kích thước
đầu vào là \(N + 2P\), giá trị \(n\) trong \((3)\) cần thỏa mãn:</p>

\[0 \leq nS + i &lt; N+2P, ~\forall i = 0, 1, \dots, f-1 \Leftrightarrow n \leq
\frac{N + 2P -f}{S}\]

<p>Thông thường, \(P\) và \(S\) được chọn sao cho \(\frac{N+2P - f}{S}\) là số nguyên.
Điều này kéo theo kích thước tổng quát của đầu ra khi có thêm lề \(P\) và bước trượt
\(S\) là:</p>

<hr />

\[N_1 = \frac{N + 2P - f}{S} + 1 \quad \quad \quad (4)\]

<hr />
<p>Công thức (4) rất quan trọng, chúng ta cần nhớ để thiết kế kích thước của các bộ
lọc, kích thước lề và bước trượt trong các mạng neuron tích chập.</p>

<p>Tích chập một chiều có thể được thực hiện bằng numpy như dưới đây. Ở đây, hệ số
điều chỉnh <code class="language-plaintext highlighter-rouge">b</code> được thêm vào cho trường hợp tổng quát:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">conv1d</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="s">"""
    compute 1d convolutional (with bias)
    """</span>
    <span class="n">w_old</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a_pad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s">'constant'</span><span class="p">,</span> <span class="n">constant_values</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">w_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">w_old</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="n">a_res</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w_new</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w_new</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">stride</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">f</span>
        <span class="n">a_res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">a_pad</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> 
    <span class="k">return</span> <span class="n">a_res</span> 
</code></pre></div></div>

<p><a name="-tich-chap-hai-chieu"></a></p>

<h2 id="2-tích-chập-hai-chiều">2. Tích chập hai chiều</h2>

<p>Tích chập được mở rộng ra cho trường hợp dữ liệu nhiều chiều. Trong phạm vi bài
viết, 
chúng ta sẽ dừng lại ở phép tính tích chập hai chiều với dữ liệu đầu vào chủ yếu
là ảnh.</p>

<p>Cách tính tích chập hai chiều với các trường hợp thêm lề và bước trượt khác nhau
được minh họa trên Hình 4. Các ảnh động này được lấy từ tài khoản <a href="https://github.com/vdumoulin/conv_arithmetic">Github
vdumoulin</a>.</p>

<hr />

<table style="width:100%; table-layout:fixed;">
  <tr>
    <td><img width="150px" src="/assets/37_conv2d/gif/no_padding_no_strides.gif" /></td>
    <td><img width="150px" src="/assets/37_conv2d/gif/arbitrary_padding_no_strides.gif" /></td>
    <td><img width="150px" src="/assets/37_conv2d/gif/same_padding_no_strides.gif" /></td>
  </tr>
  <tr>
    <td>\(P = 0, S = 1\)</td>
    <td>\(P\) bất kỳ, \(S = 1\)</td>
    <td>\(P = (f-1)/2, S =1\)</td>
  </tr>
  <tr>
    <td><img width="150px" src="/assets/37_conv2d/gif/no_padding_strides.gif" /></td>
    <td><img width="150px" src="/assets/37_conv2d/gif/padding_strides.gif" /></td>
    <td><img width="150px" src="/assets/37_conv2d/gif/padding_strides_odd.gif" /></td>
  </tr>
  <tr>
    <td>\(P = 0, S = 2\)</td>
    <td>\(P = (f-1)/2, S = 2\)</td>
    <td>\(\frac{N + 2P - f}{S} \notin \mathbb{N}\)</td>
  </tr>
</table>
<div class="thecap">Hình 4: Minh họa tích chập hai chiều đơn kênh với các cặp \((P, S)\).</div>
<hr />

<p>Về cơ bản, bộ lọc (màu xám) trượt khắp tín hiệu hai chiều đầu vào (màu lam) theo thứ tự từ
trái qua phải, từ trên xuống dưới. Tại mỗi vị trí, các giá trị của bộ lọc và đầu
vào tương ứng được nhân với nhau rồi cộng lại để thu được kết quả đầu ra. Hệ số
điều chỉnh cũng có thể được thêm vào.</p>

<p><a name="-tin-hieu-don-kenh"></a></p>

<h3 id="21-tín-hiệu-đơn-kênh">2.1. Tín hiệu đơn kênh</h3>
<p>Trong trường hợp tín hiệu đầu vào và bộ lọc là các ma trận hai chiều đơn kênh
(ảnh màu có thể được cọi là tín hiệu hai chiều với ba kênh, ảnh xám là tín hiệu
hai chiều đơn kênh). 
Cách tính tích chập có thể được thực hiện như sau:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">conv2d_11</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="s">"""
    A: input, A.shape = (n_H_old, n_W_old)
    W: filter, W.shape = (f, f)
    """</span>
    <span class="n">n_H_old</span><span class="p">,</span> <span class="n">n_W_old</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">A_pad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pad</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s">'constant'</span><span class="p">,</span> <span class="n">constant_values</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># new shape 
</span>    <span class="n">n_H_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_H_old</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="n">n_W_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_W_old</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="c1"># result
</span>    <span class="n">A_res</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_H_new</span><span class="p">,</span> <span class="n">n_W_new</span><span class="p">))</span>
    <span class="c1"># compute 
</span>    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_H_new</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_W_new</span><span class="p">):</span>
            <span class="n">h_start</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">stride</span> 
            <span class="n">h_end</span> <span class="o">=</span> <span class="n">h_start</span> <span class="o">+</span> <span class="n">f</span>
            <span class="n">v_start</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">stride</span> 
            <span class="n">v_end</span> <span class="o">=</span> <span class="n">v_start</span> <span class="o">+</span> <span class="n">f</span>
            <span class="n">A_res</span><span class="p">[</span><span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">A_pad</span><span class="p">[</span><span class="n">h_start</span><span class="p">:</span><span class="n">h_end</span><span class="p">,</span> <span class="n">v_start</span><span class="p">:</span><span class="n">v_end</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> 
    <span class="k">return</span> <span class="n">A_res</span> 

</code></pre></div></div>

<p>Ở đây ta giả sử rằng mỗi phía của tín hiệu hai chiều được thêm một đại lượng lề <code class="language-plaintext highlighter-rouge">pad</code> bằng nhau. Đoạn mã này có thể dễ 
dàng được mở rộng ra cho trường hợp thêm lề không đều. Tương tự, bộ 
lọc không nhất thiết vuông. Tuy nhiên, các trường hợp này ít xuất hiện trên thực tế.</p>

<p><strong>Giảm nhiễu, làm mờ ảnh</strong></p>

<p>Tiếp theo, chúng ta cùng xem việc áp dụng các bộ lọc khác nhau vào bức ảnh trong
Hình 4b). Hình 4b) là ảnh xám tương ứng với Hình 4a).</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/python/mylady3_rgbgray.png" width="800" />
</div>
<div class="thecap">Hình 4. (a) Ảnh màu. (b) Ảnh xám tương ứng.</div>
</div>
<hr />

<p>Quan sát một ví dụ với việc khử nhiễu trong Hình 5.</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/python/mylady3_denoise.png" width="800" />
</div>
<div class="thecap">Hình 5. (a) Ảnh có nhiễu. (b) Giảm nhiễu bằng bộ lọc trung bình \(f = 3\). (c) Giảm nhiễu và làm mờ với bộ lọc trung bình \(f = 7\)</div>
</div>
<hr />

<p>Hình 5a) được tạo bằng cách thêm nhiễu Gauss vào ảnh xám:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">img_noisy</span> <span class="o">=</span> <span class="n">img_gray</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img_gray</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="mi">20</span>
</code></pre></div></div>

<p>Hình 5b) thu được bằng cách sử dụng bộ lọc trung bình với \(f = 3\):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = 3
w = 1./k**2*np.ones((f, f))
img_denoised = conv2d_11(img_noisy, w)
</code></pre></div></div>

<p>Bộ lọc được sử dụng là \(w = \frac{1}{9}\left[\begin{matrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \<br />
1&amp; 1 &amp; 1\end{matrix}\right]\). Điều này nghĩa là giá trị của một điểm ảnh đầu ra
bằng trung bình cộng của hình vuông \(3\times3\) có tâm tại vị trí tương ứng của
điểm ảnh đầu vào. Việc lấy trung bình giúp mỗi điểm ảnh đầu ra có giá trị không
quá khác biệt so với các giá trị xung quanh. Điều này gián tiếp giúp <em>giảm
nhiễu</em> (denoise). Một hiệu ứng phụ của bộ lọc trung bình là nó khiến bức ảnh ban đầu bị mờ
đi.</p>

<p>Nếu thay một bộ lọc lớn hơn với \(f = 7\), ta sẽ thu được kết quả như Hình 5c). Ta
quan sát thấy rằng các đường nét trên khuôn mặt không còn rõ ràng như hình 4b).
Bộ lọc này gián tiếp làm mờ thêm hậu cảnh ở vị trí ánh đèn phía sau cô gái.</p>

<p><strong>Dò cạnh</strong></p>

<p>Dò cạnh của vật thể là một nhiệm vụ quan trọng trong xử lý ảnh. Hình 6 biểu diễn
kết quả dò cạnh thẳng đứng và nằm ngang trong ảnh bằng hai bộ lọc đơn giản.</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/python/mylady2_edge.png" width="800" />
</div>
<div class="thecap">Hình 6. (a) Ảnh xám gốc. (b) Dò tìm các cạnh thẳng đứng trong ảnh. (c) Dò tìm các cạnh nằm ngang. </div>
</div>
<hr />

<p>Bộ lọc được sử dụng trong Hình 6b) là \(w = \left[\begin{matrix} -1 &amp; 0 &amp; 1 \\ -1
&amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1\end{matrix}\right]\). Giá trị điểm ảnh đầu ra (điểm tương ứng với
vị trí chính giữa bộ lọc) bằng tổng các điểm liền kề ở bên phải trừ đi tổng các
điểm liền kề ở bên trái. Giá trị này sẽ có trị tuyệt đối lớn nếu sự chênh lệch
giữa các điểm hai bên lớn. Điều này đồng nghĩa với việc giá trị ảnh đầu ra lớn
tại cạnh thẳng đứng của vật thể. Đồng thời, nếu bộ lọc đang ở vị trí mà các điểm trong hình
vuông \(3\times 3\) xấp xỉ nhau, giá trị điểm ảnh đầu ra tương ứng sẽ xấp xỉ
không. Trong Hình 6, các bức ảnh được hiển thị sau khi lấy trị tuyệt đối của ảnh
đầu ra. Các điểm ảnh màu đen (giá trị gần không) tương ứng với các khu vực đồng
nhất. Các điểm ảnh màu trắng (giá trị lớn) tương ứng với các cạnh thẳng đứng. Trong trường
hợp này, chỉ các cạnh có phương thẳng đứng được tìm thấy.</p>

<p>Để tìm các cạnh có phương nằm ngang, ta sử dụng bộ lọc \(w = \left[\begin{matrix}
-1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\end{matrix}\right]\) để thu được kết quả
như Hình 6c).</p>

<p>Việc tìm các cạnh có hướng bất kỳ cũng có thể được thực hiện bằng các bộ lọc phù hợp.</p>

<p>Như vậy, chúng ta có thể thu được các phép biến đổi với ảnh thông qua các bộ lọc
đơn giản được xác định từ trước. Các bộ lọc này hoàn toàn có thể được tối ưu tùy
theo dữ liệu và bài toán.</p>

<p><a name="-tich-chap-hai-chieu-tong-quat"></a></p>

<h2 id="3-tích-chập-hai-chiều-tổng-quát">3. Tích chập hai chiều tổng quát</h2>

<p>Trong trường hợp tín hiệu đầu vào đa kênh, ví dụ ảnh màu bao gồm ba kênh: đỏ,
lục, lam; mỗi kênh là một ma trận hai chiều. Giả sử kích thước của đầu vào là
\((H_0, W_0, C_0)\) với \(C_0\) là số kênh. Khi đó, bộ lọc cũng có thể được mở rộng
ra với số kênh tương ứng để có kích thước \((f, f, C_0)\) (các kênh của bộ lọc không nhất thiết bằng nhau). Để
tính đầu ra, ta cũng trượt bộ lọc đi khắp ảnh, tính tích từng thành phần tương
ứng và lấy tổng toàn bộ các tích đó. Các tính với tín hiệu đa kênh được minh
họa trong Hình 7b).</p>

<hr />

<div class="imgcap">
<div>
    <img src="/assets/37_conv2d/conv2d_viz_general.png" width="800" />
</div>
<div class="thecap">Hình 7. (a) Tích chập hai chiều đơn kênh. (b) Tích chập hai chiều đa kênh. </div>
</div>
<hr />

<p>Tổng quát, giả sử đầu vào là một mini-batch của tín hiệu có kích thước \((m,
H_0, W_0, C_0)\).  Bộ lọc cũng ở dạng tổng quát với kích thước \((f, f, C_0, C_1)\)
(\(C_1\) bộ lọc đa kênh). Khi đó, đầu ra sẽ là một mảng bốn chiều với kích thước
\((m, H_1, W_1, C_1)\).</p>

<p>Ví dụ, nếu đầu vào là \(m\) bức ảnh màu ba kênh với kích thước \((m, H_0, W_0, 3)\)
thì đầu ra sẽ là \(m\) <em>bức ảnh</em>, mỗi bức ảnh có kích thước \((H_1, W_1)\) và có
\(C_1\) kênh.</p>

<p>Việc tính tích chập hai chiều tổng quát có thể được thực hiện như sau:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">conv2d</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="s">"""
    A: input, A.shape = (m, in_height, in_width, in_channel)
    W: filters, W.shape = (f, f, in_channel, out_channel)
    b: biases, b.shape = (out_channel)
    """</span>
    <span class="k">assert</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>\
        <span class="s">'number of input channels ({}) in A != number of input channels ({}) in W'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
            <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">in_height</span><span class="p">,</span> <span class="n">in_width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">in_channel</span><span class="p">,</span> <span class="n">out_channel</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">A_pad</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pad</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s">'constant'</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># new shape
</span>    <span class="n">out_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">in_height</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">out_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">in_width</span> <span class="o">-</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">stride</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">A_res</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">out_height</span><span class="p">,</span> <span class="n">out_width</span><span class="p">,</span> <span class="n">out_channel</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_width</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_channel</span><span class="p">):</span>
                    <span class="n">h_start</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">stride</span>
                    <span class="n">h_end</span> <span class="o">=</span> <span class="n">h_start</span> <span class="o">+</span> <span class="n">f</span>
                    <span class="n">w_start</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">stride</span>
                    <span class="n">w_end</span> <span class="o">=</span> <span class="n">w_start</span> <span class="o">+</span> <span class="n">f</span>
                    <span class="n">a_slide</span> <span class="o">=</span> <span class="n">A_pad</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">h_start</span><span class="p">:</span> <span class="n">h_end</span><span class="p">,</span> <span class="n">w_start</span><span class="p">:</span><span class="n">w_end</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">A_res</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">a_slide</span> <span class="o">*</span> <span class="n">W</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A_res</span>
</code></pre></div></div>

<p><a name="-ket-luan"></a></p>

<h2 id="4-kết-luận">4. Kết luận</h2>
<p>Tích chập hai chiều tổng quát và các biến thể đóng vai trò quan trọng trong việc
xây dựng các mạng neuron tích chập. Các thành phần cơ bản của một mạng
neuron tích chập sẽ được đề cập trong bài tiếp theo. Mời các bạn đón đọc.</p>

<p>Mã nguồn trong bài này có thể được tìm thấy <a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/37_conv2d/python/conv2d.ipynb">tại đây</a>.</p>

<p><a name="-tai-lieu-tham-khao"></a></p>

<h2 id="5-tài-liệu-tham-khảo">5. Tài liệu tham khảo</h2>

<ol>
  <li>
    <p><a href="http://setosa.io/ev/image-kernels/">Image kernels explained visually</a></p>
  </li>
  <li>
    <p><a href="https://github.com/vdumoulin/conv_arithmetic">A technical report on convolution arithmetic in the context of deep learning</a></p>
  </li>
</ol>
:ET