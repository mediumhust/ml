I"Ȣ<p><strong>Trong trang này:</strong>
<!-- MarkdownTOC --></p>

<ul>
  <li><a href="#-gioi-thieu">1. Giới thiệu</a></li>
  <li><a href="#-validation">2. Validation</a>
    <ul>
      <li><a href="#-validation-1">2.1. Validation</a></li>
      <li><a href="#-cross-validation">2.2. Cross-validation</a></li>
    </ul>
  </li>
  <li><a href="#-regularization">3. Regularization</a>
    <ul>
      <li><a href="#-early-stopping">3.1. Early Stopping</a></li>
      <li><a href="#-them-so-hang-vao-ham-mat-mat">3.2. Thêm số hạng vào hàm mất mát</a></li>
      <li><a href="#-%5C%5Cl%5C%5C-regularization">3.3. \(l_2\) regularization</a>
        <ul>
          <li><a href="#vi-du-ve-weight-decay-voi-mlp">Ví dụ về Weight Decay với MLP</a></li>
        </ul>
      </li>
      <li><a href="#-tikhonov-regularization">3.4. Tikhonov regularization</a></li>
      <li><a href="#-regularizers-for-sparsity">3.5. Regularizers for sparsity</a></li>
      <li><a href="#-regularization-trong-sklearn">3.6. Regularization trong sklearn</a></li>
    </ul>
  </li>
  <li><a href="#-cac-phuong-phap-khac">4. Các phương pháp khác</a></li>
  <li><a href="#-tom-tat-noi-dung">5. Tóm tắt nội dung</a></li>
  <li><a href="#-tai-lieu-tham-khao">6. Tài liệu tham khảo</a></li>
</ul>

<!-- /MarkdownTOC -->

<p>Overfitting không phải là một thuật toán trong Machine Learning. Nó là một hiện tượng không mong muốn thường gặp, người xây dựng mô hình Machine Learning cần nắm được các kỹ thuật để tránh hiện tượng này.</p>

<p><a name="-gioi-thieu"></a></p>

<p><a name="-gioi-thieu"></a></p>
<h2 id="1-giới-thiệu">1. Giới thiệu</h2>
<p>Đây là một câu chuyện của chính tôi khi lần đầu biết đến Machine Learning.</p>

<p>Năm thứ ba đại học, một thầy giáo có giới thiệu với lớp tôi về Neural Networks. Lần đầu tiên nghe thấy khái niệm này, chúng tôi hỏi thầy mục đích của nó là gì. Thầy nói, về cơ bản, từ dữ liệu cho trước, chúng ta cần tìm một hàm số để biến các các điểm đầu vào thành các điểm đầu ra tương ứng, không cần chính xác, chỉ cần xấp xỉ thôi.</p>

<p>Lúc đó, vốn là một học sinh chuyên toán, làm việc nhiều với đa thức ngày cấp ba, tôi đã quá tự tin trả lời ngay rằng <a href="http://vuontoanblog.blogspot.com/2012/10/polynomial-interpolation-lagrange.html">Đa thức Nội suy Lagrange</a> có thể làm được điều đó, miễn là các điểm đầu vào khác nhau đôi một! Thầy nói rằng “những gì ta biết chỉ là nhỏ xíu so với những gì ta chưa biết”. Và đó là những gì tôi muốn bắt đầu trong bài viết này.</p>

<p>Nhắc lại một chút về Đa thức nội suy Lagrange: Với \(N\) cặp điểm dữ liệu \((x_1, y_1), (x_2, y_2), \dots, (x_N, y_N)\) với các \(x_i\) kháu nhau đôi một, luôn tìm được một đa thức \(P(.)\) bậc không vượt quá \(N-1\) sao cho \(P(x_i) = y_i, ~\forall i = 1, 2, \dots, N\). Chẳng phải điều này giống với việc ta đi tìm một mô hình phù hợp (fit) với dữ liệu trong bài toán <a href="/2016/12/27/categories/#supervised-learning-hoc-co-giam-sat">Supervised Learning</a> hay sao? Thậm chí điều này còn tốt hơn vì trong Supervised Learning ta chỉ cần xấp xỉ thôi.</p>

<p>Sự thật là nếu một mô hình <em>quá fit</em> với dữ liệu thì nó sẽ gây phản tác dụng! Hiện tượng <em>quá fit</em> này trong Machine Learning được gọi là <em>overfitting</em>, là điều mà khi xây dựng mô hình, chúng ta luôn cần tránh. Để có cái nhìn đầu tiên về overfitting, chúng ta cùng xem Hình dưới đây. Có 50 điểm dữ liệu được tạo bằng một đa thức bậc ba cộng thêm nhiễu. Tập dữ liệu này được chia làm hai, 30 điểm dữ liệu màu đỏ cho training data, 20 điểm dữ liệu màu vàng cho test data. Đồ thị của đa thức bậc ba này được cho bởi đường màu xanh lục. Bài toán của chúng ta là giả sử ta không biết mô hình ban đầu mà chỉ biết các điểm dữ liệu, hãy tìm một mô hình “tốt” để mô tả dữ liệu đã cho.</p>

<hr />

<div>
<table width="100%" style="border: 0px solid white">
   <tr>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/linreg_2.png" />
         </td>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/linreg_4.png" />
        </td>

    </tr>

    <tr>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/linreg_8.png" />
         </td>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/linreg_16.png" />
        </td>

    </tr>
</table>
<div class="thecap"> Underfitting và Overfitting với Polynomial Regression (<a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/15_overfitting/LinReg.ipynb">Source code</a>).
</div>
</div>
<hr />

<p>Với những gì chúng ta đã biết từ bài <a href="/2016/12/28/linearregression/#cac-bai-toan-co-the-giai-bang-linear-regression">Linear Regression</a>, với loại dữ liệu này, chúng ta có thể áp dụng <a href="https://en.wikipedia.org/wiki/Polynomial_regression">Polynomial Regression</a>. Bài toán này hoàn toàn có thể được giải quyết bằng Linear Regression với dữ liệu mở rộng cho một cặp điểm \((x, y)\) là \((\mathbf{x}, y)\) với \(\mathbf{x} = [1, x, x^2, x^3, \dots, x^d]^T\) cho đa thức bậc \(d\). Điều quan trọng là chúng ta cần tìm bậc \(d\) của đa thức cần tìm.</p>

<p>Rõ ràng là một đa thức bậc không vượt quá 29 có thể <em>fit</em> được hoàn toàn với 30 điểm trong training data. Chúng ta cùng xét vài giá trị \(d = 2, 4, 8, 16\). Với \(d = 2\), mô hình không thực sự tốt vì mô hình dự đoán quá khác so với mô hình thực. Trong trường hợp này, ta nói mô hình bị <em>underfitting</em>. Với \(d = 8\), với các điểm dữ liệu trong khoảng của training data, mô hình dự đoán và mô hình thực là khá giống nhau. Tuy nhiên, về phía phải, đa thức bậc 8 cho kết quả hoàn toàn ngược với <em>xu hướng của dữ liệu</em>. Điều tương tự xảy ra trong trường hợp \(d = 16\). Đa thức bậc 16 này <em>quá fit</em> dữ liệu trong khoảng đang xét, và <em>quá fit</em>, tức <em>không được mượt</em> trong khoảng dữ liệu training. Việc <em>quá fit</em> trong trường hợp bậc 16 không tốt vì mô hình đang cố gắng mô tả <em>nhiễu</em> hơn là dữ liệu. Hai trường hợp đa thức bậc cao này được gọi là <em>Overfitting</em>.</p>

<p><em>Nếu bạn nào biết về Đa thức nội suy Lagrange thì có thể hiểu được hiện tượng sai số lớn với các điểm nằm ngoài khoảng của các điểm đã cho. Đó chính là lý do phương pháp đó có từ “nội suy”, với các trường hợp “ngoại suy”, kết quả thường không chính xác.</em></p>

<p>Với \(d = 4\), ta được mô hình dự đoán khá giống với mô hình thực. Hệ số bậc cao nhất tìm được rất gần với 0 (xem kết quả trong <a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/15_overfitting/LinReg.ipynb">source code</a>), vì vậy đa thức bậc 4 này khá gần với đa thức bậc 3 ban đầu. Đây chính là một mô hình tốt.</p>

<p>Overfitting là hiện tượng mô hình tìm được <em>quá khớp</em> với dữ liệu training. Việc <em>quá khớp</em> này có thể dẫn đến việc dự đoán nhầm nhiễu, và chất lượng mô hình không còn tốt trên dữ liệu test nữa. <a href="/general/2017/02/06/featureengineering/#main-algorithms">Dữ liệu test được giả sử là không được biết trước, và không được sử dụng để xây dựng các mô hình Machine Learning</a>.</p>

<p>Về cơ bản, overfitting xảy ra khi mô hình quá phức tạp để mô phỏng training data. Điều này đặc biệt xảy ra khi lượng dữ liệu training quá nhỏ trong khi độ phức tạp của mô hình quá cao. Trong ví dụ trên đây, độ phức tạp của mô hình có thể được coi là bậc của đa thức cần tìm. Trong <a href="/2017/02/24/mlp/">Multi-layer Perceptron</a>, độ phức tạp của mô hình có thể được coi là số lượng hidden layers và số lượng units trong các hidden layers.</p>

<p>Vậy, có những kỹ thuật nào giúp tránh Overfitting?</p>

<p>Trước hết, chúng ta cần một vài đại lượng để đánh giá chất lượng của mô hình trên training data và test data. Dưới đây là hai đại lượng đơn giản, với giả sử \(\mathbf{y}\) là đầu ra thực sự (có thể là vector), và \(\mathbf{\hat{y}}\) là đầu ra dự đoán bởi mô hình:</p>

<p><strong>Train error:</strong> Thường là hàm mất mát áp dụng lên training data. Hàm mất mát này cần có một thừa số \(\frac{1}{N_{\text{train}}} \) để tính giá trị trung bình, tức mất mát trung bình trên mỗi điểm dữ liệu. Với Regression, đại lượng này thường được định nghĩa:
\[
\text{train error}= \frac{1}{N_{\text{train}}} \sum_{\text{training set}} \|\mathbf{y} - \mathbf{\hat{y}}\|_p^2
\]
với \(p\) <a href="/math/#mot-so-chuan-thuong-dung">thường bằng 1 hoặc 2</a>.</p>

<p>Với Classification, trung bình cộng của <a href="/2017/02/17/softmax/#-cross-entropy">cross entropy</a> có thể được sử dụng.</p>

<p><strong>Test error:</strong> Tương tự như trên nhưng áp dụng mô hình tìm được vào <strong>test data</strong>. Chú ý rằng, khi xây dựng mô hình, ta không được sử dụng thông tin trong tập dữ liệu test. Dữ liệu test chỉ được dùng để đánh giá mô hình. Với Regression, đại lượng này thường được định nghĩa:
\[
\text{test error}= \frac{1}{N_{\text{test}}} \sum_{\text{test set}} \|\mathbf{y} - \mathbf{\hat{y}}\|_p^2
\]</p>

<p>với \(p\) giống như \(p\) trong cách tính <em>train error</em> phía trên.</p>

<p><em>Việc lấy trung bình là quan trọng vì lượng dữ liệu trong hai tập hợp training và test có thể chênh lệch rất nhiều.</em></p>

<p>Một mô hình được coi là tốt (fit) nếu cả <em>train error</em> và <em>test error</em> đều thấp. Nếu <em>train error</em> thấp nhưng <em>test error</em> cao, ta nói mô hình bị overfitting. Nếu <em>train error</em> cao và <em>test error</em> cao, ta nói mô hình bị underfitting. Nếu <em>train error</em> cao nhưng <em>test error</em> thấp, tôi không biết tên của mô hình này, vì cực kỳ may mắn thì hiện tượng này mới xảy ra, hoặc có chỉ khi tập dữ liệu test quá nhỏ.</p>

<p>Chúng ta cùng đi vào phương pháp đầu tiên</p>

<p><a name="-validation"></a></p>

<p><a name="-validation"></a></p>
<h2 id="2-validation">2. Validation</h2>
<p><a name="-validation-1"></a></p>

<p><a name="-validation-1"></a></p>
<h3 id="21-validation">2.1. Validation</h3>
<p>Chúng ta vẫn quen với việc chia tập dữ liệu ra thành hai tập nhỏ: training data và test data. Và một điều tôi vẫn muốn nhắc lại là khi xây dựng mô hình, ta không được sử dụng test data. Vậy làm cách nào để biết được chất lượng của mô hình với <em>unseen data</em> (tức dữ liệu chưa nhìn thấy bao giờ)?</p>

<p>Phương pháp đơn giản nhất là <em>trích</em> từ tập training data ra một tập con nhỏ và thực hiện việc đánh giá mô hình trên tập con nhỏ này. Tập con nhỏ <strong>được trích ra từ training set</strong> này được gọi là <em>validation set</em>. Lúc này, <strong>training set là phần còn lại của training set ban đầu</strong>. Train error được tính trên training set mới này, và có một khái niệm nữa được định nghĩa tương tự như trên <em>validation error</em>, tức error được tính trên tập validation.</p>

<blockquote>
  <p>Việc này giống như khi bạn ôn thi. Giả sử bạn không biết đề thi như thế nào nhưng có 10 bộ đề thi từ các năm trước. Để xem trình độ của mình trước khi thi thế nào, có một cách là bỏ riêng một bộ đề ra, không ôn tập gì. Việc ôn tập sẽ được thực hiện dựa trên 9 bộ còn lại. Sau khi ôn tập xong, bạn bỏ bộ đề đã để riêng ra làm thử và kiểm tra kết quả, như thế mới “khách quan”, mới giống như thi thật. 10 bộ đề ở các năm trước là “toàn bộ” training set bạn có. Để tránh việc học lệch, học tủ theo chỉ 10 bộ, bạn tách 9 bộ ra làm training set thật, bộ còn lại là validation test. Khi làm như thế thì mới đánh giá được việc bạn học đã tốt thật hay chưa, hay chỉ là <em>học tủ</em>. Vì vậy, <em>Overfitting</em> còn có thể so sánh với việc <em>Học tủ</em> của con người.</p>
</blockquote>

<p>Với khái niệm mới này, ta tìm mô hình sao cho cả <em>train error</em> và <em>validation error</em> đều nhỏ, qua đó có thể dự đoán được rằng <em>test error</em> cũng nhỏ. Phương pháp thường được sử dụng là sử dụng nhiều mô hình khác nhau. Mô hình nào cho <em>validation error</em> nhỏ nhất sẽ là mô hình tốt.</p>

<p>Thông thường, ta bắt đầu từ mô hình đơn giản, sau đó tăng dần độ phức tạp của mô hình. Tới khi nào <em>validation error</em> có chiều hướng tăng lên thì chọn mô hình ngay trước đó. Chú ý rằng mô hình càng phức tạp, <em>train error</em> có xu hướng càng nhỏ đi.</p>

<p>Hính dưới đây mô tả ví dụ phía trên với bậc của đa thức tăng từ 1 đến 8. Tập validation bao gồm 10 điểm được lấy ra từ tập training ban đầu.</p>

<div class="imgcap">
<img src="\assets\15_overfitting\linreg_val.png" align="center" width="500" />
<div class="thecap">Hình 2: Lựa chọn mô hình dựa trên validation (<a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/15_overfitting/LinReg-validation.ipynb">Source code</a>).</div>
</div>
<p>Chúng ta hãy tạm chỉ xét hai đường màu lam và đỏ, tương ứng với <em>train error</em> và <em>validation error</em>. Khi bậc của đa thức tăng lên, <em>train error</em> có xu hướng giảm. Điều này dễ hiểu vì đa thức bậc càng cao, dữ liệu càng được <em>fit</em>. Quan sát đường màu đỏ, khi bậc của đa thức là 3 hoặc 4 thì <em>validation error</em> thấp, sau đó tăng dần lên. Dựa vào <em>validation error</em>, ta có thể xác định được bậc cần chọn là 3 hoặc 4. Quan sát tiếp đường màu lục, tương ứng với <em>test error</em>, thật là trùng hợp, với bậc bằng 3 hoặc 4, <em>test error</em> cũng đạt giá trị nhỏ nhất, sau đó tăng dần lên. Vậy cách làm này ở đây đã tỏ ra hiệu quả.</p>

<p>Việc không sử dụng <em>test data</em> khi lựa chọn mô hình ở trên nhưng vẫn có được kết quả khả quan vì ta giả sử rằng <em>validation data</em> và <em>test data</em> có chung một đặc điểm nào đó. Và khi cả hai đều là <em>unseen data</em>, <em>error</em> trên hai tập này sẽ tương đối giống nhau.</p>

<p>Nhắc lại rằng, khi bậc nhỏ (bằng 1 hoặc 2), cả ba error đều cao, ta nói mô hình bị <em>underfitting</em>.</p>

<p><a name="-cross-validation"></a></p>

<p><a name="-cross-validation"></a></p>
<h3 id="22-cross-validation">2.2. Cross-validation</h3>
<p>Trong nhiều trường hợp, chúng ta có rất hạn chế số lượng dữ liệu để xây dựng mô hình. Nếu lấy quá nhiều dữ liệu trong tập training ra làm dữ liệu validation, phần dữ liệu còn lại của tập training là không đủ để xây dựng mô hình. Lúc này, tập validation phải thật nhỏ để giữ được lượng dữ liệu cho training đủ lớn. Tuy nhiên, một vấn đề khác nảy sinh. Khi tập validation quá nhỏ, hiện tượng overfitting lại có thể xảy ra với tập training còn lại. Có giải pháp nào cho tình huống này không?</p>

<p>Câu trả lời là <em>cross-validation</em>.</p>

<p><em>Cross validation</em> là một cải tiến của <em>validation</em> với lượng dữ liệu trong tập validation là nhỏ nhưng chất lượng mô hình được đánh giá trên nhiều tập <em>validation</em> khác nhau. Một cách thường đường sử dụng là chia tập training ra \(k\) tập con không có phần tử chung, có kích thước gần bằng nhau. Tại mỗi lần kiểm thử , được gọi là <em>run</em>, một trong số \(k\) tập con được lấy ra làm <em>validate set</em>. Mô hình sẽ được xây dựng dựa vào hợp của \(k-1\) tập con còn lại. Mô hình cuối được xác định dựa trên trung bình của các <em>train error</em> và <em>validation error</em>. Cách làm này còn có tên gọi là <strong>k-fold cross validation</strong>.</p>

<p>Khi \(k\) bằng với số lượng phần tử trong tập <em>training</em> ban đầu, tức mỗi tập con có đúng 1 phần tử, ta gọi kỹ thuật này là <strong>leave-one-out</strong>.</p>

<p>Sklearn hỗ trợ rất nhiều phương thức cho phân chia dữ liệu và tính toán <em>scores</em> của các mô hình. Bạn đọc có thể xem thêm tại <a href="http://scikit-learn.org/stable/modules/cross_validation.html">Cross-validation: evaluating estimator performance</a>.</p>

<p><a name="-regularization"></a></p>

<p><a name="-regularization"></a></p>
<h2 id="3-regularization">3. Regularization</h2>

<p>Một nhược điểm lớn của <em>cross-validation</em> là số lượng <em>training runs</em> tỉ lệ thuận với \(k\). Điều đáng nói là mô hình polynomial như trên chỉ có một tham số cần xác định là bậc của đa thức. Trong các bài toán Machine Learning, lượng tham số cần xác định thường lớn hơn nhiều, và khoảng giá trị của mỗi tham số cũng rộng hơn nhiều, chưa kể đến việc có những tham số có thể là số thực. Như vậy, việc chỉ xây dựng một mô hình thôi cũng là đã rất phức tạp rồi. Có một cách giúp số mô hình cần huấn luyện giảm đi nhiều, thậm chí chỉ một mô hình. Cách này có tên gọi chung là <em>regularization</em>.</p>

<p><em>Regularization</em>, một cách cơ bản, là thay đổi mô hình một chút để tránh overfitting trong khi vẫn giữ được tính tổng quát của nó (tính tổng quát là tính mô tả được nhiều dữ liệu, trong cả tập training và test). Một cách cụ thể hơn, ta sẽ tìm cách <em>di chuyển</em> nghiệm của bài toán tối ưu hàm mất mát tới một điểm gần nó. Hướng di chuyển sẽ là hướng làm cho mô hình <em>ít phức tạp hơn</em> mặc dù giá trị của hàm mất mát có tăng lên một chút.</p>

<p>Một kỹ thuật rất đơn giản là <em>early stopping</em>.</p>

<p><a name="-early-stopping"></a></p>

<p><a name="-early-stopping"></a></p>
<h3 id="31-early-stopping">3.1. Early Stopping</h3>
<p>Trong nhiều bài toán Machine Learning, chúng ta cần sử dụng các thuật toán lặp để tìm ra nghiệm, ví dụ như Gradient Descent. Nhìn chung, hàm mất mát giảm dần khi số vòng lặp tăng lên. Early stopping tức dừng thuật toán trước khi hàm mất mát đạt giá trị quá nhỏ, giúp tránh overfitting.</p>

<p>Vậy dừng khi nào là phù hợp?</p>

<p>Một kỹ thuật thường được sử dụng là tách từ training set ra một tập validation set như trên. Sau một (hoặc một số, ví dụ 50) vòng lặp, ta tính cả <em>train error</em> và <em>validation error</em>, đến khi <em>validation error</em> có chiều hướng tăng lên thì dừng lại, và quay lại sử dụng mô hình tương ứng với điểm và <em>validation error</em> đạt giá trị nhỏ.</p>

<div class="imgcap">
<img src="\assets\15_overfitting\EarlyStopping.png" align="center" width="400" />
<div class="thecap">Hình 3: Early Stopping. Đường màu xanh là <i>train error</i>, đường màu đỏ là <i>validation error</i>. Trục x là số lượng vòng lặp, trục y là error. Mô hình được xác định tại vòng lặp mà <i>validation error</i> đạt giá trị nhỏ nhất.  (<a href="https://en.wikipedia.org/wiki/Overfitting">Overfitting - Wikipedia</a>).</div>
</div>
<p>Hình trên đây mô tả cách tìm điểm <em>stopping</em>. Chúng ta thấy rằng phương pháp này khá giống với phương pháp tìm bậc của đa thức ở phần trên của bài viết.</p>

<p><a name="-them-so-hang-vao-ham-mat-mat"></a></p>

<p><a name="-them-so-hang-vao-ham-mat-mat"></a></p>
<h3 id="32-thêm-số-hạng-vào-hàm-mất-mát">3.2. Thêm số hạng vào hàm mất mát</h3>

<p>Kỹ thuật regularization phổ biến nhất là thêm vào hàm mất mát một số hạng nữa. Số hạng này thường dùng để đánh giá độ phức tạp của mô hình. Số hạng này càng lớn, thì mô hình càng phức tạp. <em>Hàm mất mát mới</em> này thường được gọi là <strong>regularized loss function</strong>, thường được định nghĩa như sau:
\[
J_{\text{reg}}(\theta) = J(\theta) + \lambda R(\theta)
\]</p>

<p>Nhắc lại rằng \(\theta\) được dùng để ký hiệu các biến trong mô hình, chẳng hạn như các hệ số \(\mathbf{w}\) trong Neural Networks. \(J(\theta)\) ký hiệu cho hàm mất mát (<em>loss function</em>) và \(R(\theta)\) là số hạng <em>regularization</em>. \(\lambda\) thường là một số dương để cân bằng giữa hai đại lượng ở vế phải.</p>

<p>Việc tối thiểu <em>regularized loss function</em>, nói một cách tương đối, đồng nghĩa với việc tối thiểu cả <em>loss function</em> và số hạng <em>regularization</em>. Tôi dùng cụm “nói một cách tương đối” vì nghiệm của bài toán tối ưu <em>loss function</em> và <strong>regularized loss function</strong> là khác nhau.  Chúng ta vẫn mong muốn rằng sự khác nhau này là nhỏ, vì vậy tham số regularization (<em>regularization parameter</em>) \(\lambda\) thường được chọn là một số nhỏ để biểu thức regularization không làm giảm quá nhiều chất lượng của nghiệm.</p>

<p>Với các mô hình Neural Networks, một số kỹ thuật regularization thường được sử dụng là:</p>

<p><a name="-\\l\\-regularization"></a></p>

<p><a name="-%5C%5Cl%5C%5C-regularization"></a></p>
<h3 id="33-l_2-regularization">3.3. \(l_2\) regularization</h3>
<p>Trong kỹ thuật này:
\[
R(\mathbf{w}) = \|\mathbf{w}\|_2^2
\]
tức norm 2 của hệ số.</p>

<p><em>Nếu bạn đọc chưa quen thuộc với khái niệm norm, bạn được khuyến khích đọc <a href="/math/#-norms-chuan">phần phụ lục này</a></em>.</p>

<p>Hàm số này có một vài đặc điểm đang lưu ý:</p>

<ul>
  <li>Thứ nhất, \(\|\mathbf{w}\|_2^2\) là một hàm số <em>rất mượt</em>, tức có đạo hàm tại mọi điểm, đạo hàm của nó đơn giản là \(\mathbf{w}\), vì vậy đạo hàm của <em>regularized loss function</em> cũng rất dễ tính, chúng ta có thể hoàn toàn dùng các phương pháp dựa trên gradient để cập nhật nghiệm. Cụ thể:
\[
\frac{\partial J_{\text{reg}} }{\partial \mathbf{w}} = \frac{\partial J}{\partial \mathbf{w}} + \lambda \mathbf{w}
\]</li>
  <li>Thứ hai, việc tối thiểu \(\|\mathbf{w}\|_2^2\) đồng nghĩa với việc khiến cho các giá trị của hệ số \(\mathbf{w}\) trở nên nhỏ gần với 0. Với Polynomial Regression, việc các hệ số này nhỏ có thể giúp các hệ số ứng với các số hạng bậc cao là nhỏ, giúp tránh overfitting. Với Multi-layer Perceptron, việc các hệ số này nhỏ giúp cho nhiều hệ số trong các ma trận trọng số là nhỏ. Điều này tương ứng với việc số lượng các hidden units <em>hoạt động</em> (khác không) là nhỏ, cũng giúp cho MLP tránh được hiện tượng overfitting.</li>
</ul>

<p>\(l_2\) regularization là kỹ thuật được sử dụng nhiều nhất để giúp Neural Networks tránh được overfitting. Nó còn có tên gọi khác là <strong>weight decay</strong>. <em>Decay</em> có nghĩa là <em>tiêu biến</em>.</p>

<p>Trong Xác suất thống kê, Linear Regression với \(l_2\) regularization được gọi là <a href="https://en.wikipedia.org/wiki/Tikhonov_regularization"><strong>Ridge Regression</strong></a>. Hàm mất mát của <em>Ridge Regression</em> có dạng:
\[
J(\mathbf{w}) = \frac{1}{2} \|\mathbf{y} - \mathbf{Xw}\|_2^2 + \lambda \|\mathbf{w}\|_2^2
\]
trong đó, số hạng đầu tiên ở vế phải chính là hàm mất mát của Linear Regression. Số hạng thứ hai chính là phần regularization.</p>

<p><a name="vi-du-ve-weight-decay-voi-mlp"></a></p>

<p><a name="vi-du-ve-weight-decay-voi-mlp"></a></p>
<h4 id="ví-dụ-về-weight-decay-với-mlp">Ví dụ về Weight Decay với MLP</h4>
<p>Chúng ta sử dụng <a href="/2017/02/24/mlp/#-vi-du-tren-python">mô hình MLP giống như bài trước</a> nhưng dữ liệu có khác đi đôi chút.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># To support both python 2 and python 3
</span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">means</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">cov</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">X0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">means</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cov</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">X1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">means</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cov</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">X2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">means</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cov</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</code></pre></div></div>
<p>Dữ liệu được tạo là ba cụm tuân theo phân phối chuẩn có tâm ở <code class="language-plaintext highlighter-rouge">[[-1, -1], [1, -1], [0, 1]]</code>.</p>

<p>Trong ví dụ này, chúng ta sử dụng số hạng regularization:
\[
\lambda R(\mathbf{W}) = \lambda \sum_{l=1}^L \|\mathbf{W}^{(l)}\|_F^2
\]</p>

<p>với \(\|.\|_F\) là <a href="/math/#cho-ma-tran">Frobenius norm</a>, là căn bậc hai của tổng bình phường các phẩn tử của ma trận.</p>

<p>(Bạn đọc được khuyến khích đọc bài <a href="/2017/02/24/mlp/">MLP</a> để hiểu các ký hiệu).</p>

<p>Chú ý rằng weight decay ít khi được áp dụng lên biases. Tôi thay đổi tham số regularization \(\lambda\) và nhận được kết quả như sau:</p>

<hr />

<div>
<table width="100%" style="border: 0px solid white">
   <tr>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/nnet_reg0.png" />
         </td>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/nnet_reg0.001.png" />
        </td>

    </tr>

    <tr>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/nnet_reg0.01.png" />
         </td>
        <td width="40%" style="border: 0px solid white">
        <img style="display:block;" width="100%" src="/assets/15_overfitting/nnet_reg0.1.png" />
        </td>

    </tr>
</table>
<div class="thecap"> Multi-layer Perceptron với Weight Decay (<a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/15_overfitting/Weight%20Decay.ipynb">Source code</a>).
</div>
</div>
<hr />

<p>Khi \(\lambda = 0\), tức không có regularization, ta nhận thấy gần như toàn bộ dữ liệu trong tập training được phân lớp đúng. Việc này khiến cho các class bị phân làm nhiều mảnh không được tự nhiên. Khi \(\lambda = 0.001\), vẫn là một số nhỏ, các đường phân chia trông tự nhiên hơn, nhưng lớp màu xanh lam vẫn bị chia làm hai bởi lớp màu xanh lục. Đây chính là biểu hiện của overfitting.</p>

<p>Khi \(\lambda\) tăng lên, tức sự ảnh hưởng của regularization tăng lên (xem hàng dưới), đường ranh giới giữa các lớp trở lên tự nhiên hơn. Nói cách khác, với \(\lambda\) đủ lớn, weight decay có tác dụng hạn chế overfitting trong MLP.</p>

<p>Bạn đọc hãy thử vào trong <a href="https://github.com/tiepvupsu/tiepvupsu.github.io/blob/master/assets/15_overfitting/Weight%20Decay.ipynb">Source code</a>, thay \(\lambda = 1\) bằng cách thay dòng cuối cùng:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mynet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>rồi chạy lại toàn bộ code, xem các đường phân lớp trông như thế nào. Gợi ý: <em>underfitting</em>.</p>

<p>Khi \(\lambda\) quá lớn, tức ta xem phần <em>regularization</em> quan trọng hơn phần <em>loss fucntion</em>, một hiện tượng xấu xảy ra là các phần tử của \(\mathbf{w}\) tiến về 0 để thỏa mãn regularization là nhỏ.</p>

<p><a href="http://scikit-learn.org/stable/modules/neural_networks_supervised.html">Sklearn có cung cấp rất nhiều chức năng cho MLP</a>, trong đó ta có thể lựa chọn số lượng hidden layers và số lượng hidden units trong mỗi layer, activation functions, weight decay, <a href="/2017/01/16/gradientdescent2/">learning rate, hệ số momentum, nesterovs_momentum</a>, có early stopping hay không, lượng dữ liệu được tách ra làm validation set, và nhiều chức năng khác.</p>

<p><a name="-tikhonov-regularization"></a></p>

<p><a name="-tikhonov-regularization"></a></p>
<h3 id="34-tikhonov-regularization">3.4. Tikhonov regularization</h3>
<p>\[
\lambda R(\mathbf{w}) = \|\Gamma \mathbf{w}\|_2^2
\]</p>

<p>Với \(\Gamma\) (viết hoa của gamma) là một ma trận. Ma trận \(\Gamma\) hay được dùng nhất là ma trận đường chéo. Nhận thấy rằng \(l_2\) regularization chính là một trường hợp đặc biệt của Tikhonov regularization với \(\Gamma = \lambda \mathbf{I}\) với \(\mathbf{I}\) là ma trận đơn vị (<em>the identity matrix</em>), tức các phần tử trên đường chéo của \(\Gamma\) là như nhau.</p>

<p>Khi các phần tử trên đường chéo của \(\Gamma\) là khác nhau, ta có một phiên bản gọi là <em>weighted \(l_2\) regularization</em>, tức đánh trọng số khác nhau cho mỗi phần tử trong \(\mathbf{w}\). Phần tử nào càng bị đánh trọng số cao thì nghiệm tương ứng càng nhỏ (để đảm bảo rằng hàm mất mát là nhỏ). Với Polynomial Regression, các phần tử ứng với hệ số bậc cao sẽ được đánh trọng số cao hơn, khiến cho xác suất để chúng gần 0 là lớn hơn.</p>

<p><a name="-regularizers-for-sparsity"></a></p>

<p><a name="-regularizers-for-sparsity"></a></p>
<h3 id="35-regularizers-for-sparsity">3.5. Regularizers for sparsity</h3>

<p>Trong nhiều trường hợp, ta muốn các hệ số <em>thực sự</em> bằng 0 chứ không phải là <em>nhỏ gần 0</em> như \(l_2\) regularization đã làm phía trên. Lúc đó, có một regularization khác được sử dụng, đó là \(l_0\) regularization:
\[
R(\mathbf{W}) = \|\mathbf{w}\|_0
\]</p>

<p>Norm 0 không phải là một norm thực sự mà là giả norm. (Bạn được khuyến khích đọc thêm về <a href="/math/#-norms-chuan">norms (chuẩn)</a>). Norm 0 của một vector là số các phần tử khác không của vector đó. Khi norm 0 nhỏ, tức rất nhiều phần tử trong vector đó bằng 0, ta nói vector đó là <em>sparse</em>.</p>

<p>Việc giải bài toán tổi thiểu norm 0 nhìn chung là khó vì hàm số này không <em>convex</em>, không liên tục. Thay vào đó, norm 1 thường được sử dụng:
\[
R(\mathbf{W}) = \|\mathbf{w}\|_1 = \sum_{i=0}^d |w_i|
\]</p>

<p>Norm 1 là tổng các trị tuyệt đối của tất cả các phần tử. Người ta đã chứng minh được rằng tối thiểu norm 1 sẽ dẫn tới nghiệm có nhiều phần tử bằng 0. Ngoài ra, vì norm 1 là một <em>norm thực sự</em> (proper norm) nên hàm số này là <em>convex</em>, và hiển nhiên là liên tục, việc giải bài toán này dễ hơn việc giải bài toán tổi thiểu norm 0. Về \(l_1\) regularization, bạn đọc có thể đọc thêm trong <a href="\\(l_1\\) regularization">lecture note</a> này. Việc giải bài toán \(l_1\) regularization nằm ngoài mục đích của tôi trong bài viết này. Tôi hứa sẽ quay lại phần này sau. (Vì đây là phần chính trong nghiên cứu của tôi).</p>

<p>Trong Thống Kê, việc sử dụng \(l_1\) regularization còn được gọi là <a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">LASSO</a> (Least Absolute Shrinkage and Selection Operator).</p>

<p>Khi cả \(l_2\) và \(l_1\) regularization được sử dụng, ta có mô hình gọi là <a href="https://en.wikipedia.org/wiki/Elastic_net_regularization">Elastic Net Regression</a>.</p>

<p><a name="-regularization-trong-sklearn"></a></p>

<p><a name="-regularization-trong-sklearn"></a></p>
<h3 id="36-regularization-trong-sklearn">3.6. Regularization trong sklearn</h3>

<p>Trong <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">sklearn</a>, ví dụ <a href="/2017/01/27/logisticregression/">Logistic Regression</a>, bạn cũng có thể sử dụng các \(l_1\) và \(l_2\) regularizations bằng cách khai báo biến <code class="language-plaintext highlighter-rouge">penalty='l1'</code> hoặc <code class="language-plaintext highlighter-rouge">penalty = 'l2'</code> và biến <code class="language-plaintext highlighter-rouge">C</code>, trong đó <code class="language-plaintext highlighter-rouge">C</code> là <em>nghịch đảo</em> của \(\lambda\). Trong các bài trước khi chưa nói về  Overfitting và Regularization, tôi có sử dụng <code class="language-plaintext highlighter-rouge">C = 1e5</code> để chỉ ra rằng \(\lambda\) là một số rất nhỏ.</p>

<p><a name="-cac-phuong-phap-khac"></a></p>

<p><a name="-cac-phuong-phap-khac"></a></p>
<h2 id="4-các-phương-pháp-khác">4. Các phương pháp khác</h2>
<p>Ngoài các phương pháp đã nêu ở trên, với mỗi mô hình, nhiều phương pháp tránh overfitting khác cũng được sử dụng. Điển hình là <a href="http://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf">Dropout trong Deep Neural Networks mới được đề xuất gần đây</a>. Một cách ngắn gọn, dropout là một phương pháp <em>tắt</em> ngẫu nhiên các units trong Networks. <em>Tắt</em> tức cho các unit giá trị bằng không và tính toán feedforward và backpropagation bình thường trong khi training. Việc này không những giúp lượng tính toán giảm đi mà còn làm giảm việc overffitng. Tôi xin được quay lại vấn đề này nếu có dịp nói  sâu về Deep Learning trong tương lai.</p>

<p>Bạn đọc có thể tìm đọc thêm với các từ khóa: <a href="https://en.wikipedia.org/wiki/Pruning_(decision_trees)">pruning</a> (tránh overfitting trong Decision Trees), <a href="https://en.wikipedia.org/wiki/VC_dimension">VC dimension</a> (đo độ phức tạp của mô hình, độ phức tạp càng lớn thì càng dễ bị overfitting).</p>

<p><a name="-tom-tat-noi-dung"></a></p>

<p><a name="-tom-tat-noi-dung"></a></p>
<h2 id="5-tóm-tắt-nội-dung">5. Tóm tắt nội dung</h2>
<ul>
  <li>
    <p>Một mô hình mô tốt là mộ mô hình có <em>tính tổng quát</em>, tức mô tả được dữ liệu cả trong lẫn ngoài tập training. Mô hình chỉ mô tả tốt dữ liệu trong tập training được gọi là <strong>overfitting</strong>.</p>
  </li>
  <li>
    <p>Để tránh overfitting, có rất nhiều kỹ thuật được sử dụng, điển hình là <strong>cross-validation</strong> và <strong>regularization</strong>. Trong Neural Networks, <strong>weight decay</strong> và <strong>dropout</strong> thường được dùng.</p>
  </li>
</ul>

<p><a name="-tai-lieu-tham-khao"></a></p>

<p><a name="-tai-lieu-tham-khao"></a></p>
<h2 id="6-tài-liệu-tham-khảo">6. Tài liệu tham khảo</h2>

<p>[1] <a href="https://en.wikipedia.org/wiki/Overfitting">Overfitting - Wikipedia</a></p>

<p>[2] <a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">Cross-validation - Wikipedia</a></p>

<p>[3] <a href="users.isr.ist.utl.pt/~wurmd/Livros/school/Bishop - Pattern Recognition And Machine Learning - Springer  2006.pdf">Pattern Recognition and Machine Learning</a></p>

<p>[4] Krogh, Anders, and John A. Hertz. <a href="https://papers.nips.cc/paper/563-a-simple-weight-decay-can-improve-generalization.pdf">“A simple weight decay can improve generalization.”</a> NIPS. Vol. 4. 1991.</p>

<p>[5] Srivastava, Nitish, et al. <a href="http://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf">“Dropout: A Simple Way to Prevent Neural Networks from  Overfitting”</a> Journal of Machine Learning Research 15.1 (2014): 1929-1958.</p>
:ET